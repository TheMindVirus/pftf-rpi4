#undef MIN
#undef MAX
/** @file
 *
 *  Differentiated System Definition Table (DSDT)
 *
 *  Copyright (c) 2020, Pete Batard <pete@akeo.ie>
 *  Copyright (c) 2018-2020, Andrey Warkentin <andrey.warkentin@gmail.com>
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  SPDX-License-Identifier: BSD-2-Clause-Patent
 *
 **/

#include <IndustryStandard/Bcm2711.h>
#include <IndustryStandard/Bcm2836.h>
#include <IndustryStandard/Bcm2836Gpio.h>
#include <IndustryStandard/Bcm2836Gpu.h>
#include <IndustryStandard/Bcm2836Pwm.h>
#include <IndustryStandard/Bcm2836Sdio.h>
#include <IndustryStandard/Bcm2836SdHost.h>

#include "AcpiTables.h"

#define BCM_ALT0 0x4
#define BCM_ALT1 0x5
#define BCM_ALT2 0x6
#define BCM_ALT3 0x7
#define BCM_ALT4 0x3
#define BCM_ALT5 0x2

//
// The ASL compiler does not support argument arithmetic in functions
// like QWordMemory (). So we need to instantiate dummy qword regions
// that we can then update the Min, Max and Length attributes of.
// The three macros below help accomplish this.
//
// QWORDMEMORYSET specifies a CPU memory range (whose base address is
// BCM2836_SOC_REGISTERS + Offset), and QWORDBUSMEMORYSET specifies
// a VPU memory range (whose base address is provided directly).
//
#define QWORDMEMORYBUF(Index)                                   \
  QWordMemory (ResourceProducer,,                               \
    MinFixed, MaxFixed, NonCacheable, ReadWrite,                \
    0x0, 0x0, 0x0, 0x0, 0x1,,, RB ## Index)

#define QWORDMEMORYSET(Index, Offset, Length)                   \
  CreateQwordField (RBUF, RB ## Index._MIN, MI ## Index)        \
  CreateQwordField (RBUF, RB ## Index._MAX, MA ## Index)        \
  CreateQwordField (RBUF, RB ## Index._LEN, LE ## Index)        \
  Store (Length, LE ## Index)                                   \
  Add (BCM2836_SOC_REGISTERS, Offset, MI ## Index)              \
  Add (MI ## Index, LE ## Index - 1, MA ## Index)

#define QWORDBUSMEMORYSET(Index, Base, Length)                  \
  CreateQwordField (RBUF, RB ## Index._MIN, MI ## Index)        \
  CreateQwordField (RBUF, RB ## Index._MAX, MA ## Index)        \
  CreateQwordField (RBUF, RB ## Index._LEN, LE ## Index)        \
  Store (Base, MI ## Index)                                     \
  Store (Length, LE ## Index)                                   \
  Add (MI ## Index, LE ## Index - 1, MA ## Index)

DefinitionBlock ("Dsdt.aml", "DSDT", 5, "RPIFDN", "RPI", 2)
{
  Scope (\_SB_)
  {
    /** @file
     *
     *  Platform Extension Plugin (PEP).
     *
     *  Copyright (c) 2019, ARM Ltd. All rights reserved.
     *  Copyright (c) 2018, Andrey Warkentin <andrey.warkentin@gmail.com>
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *
     *  SPDX-License-Identifier: BSD-2-Clause-Patent
     *
     **/
    
    Device(PEPD)
    {
      //
      // PEP virtual device.
      //
      Name (_HID, "BCM2854") // Note: Since PEP on RPi is a virtual device,
      Name (_CID, "BCM2854") // its device id needs to be generated by Microsoft
      Name (_UID, 0x0)
      Name (_CRS, ResourceTemplate ()
      {
        // No hardware resources for PEP driver are needed.
      })
    
      //
      // Processor info. PEP proprietary method to return
      // PEP_PROCESSOR_TABLE_PLAT structure.
      //
      // See Pep.h and Pep.c.
      //
      Name (_GPI, Buffer()
      {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x5F, 0x00, 0x53,
        0x00, 0x42, 0x00, 0x2E, 0x00, 0x43, 0x00, 0x50, 0x00, 0x55, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      })
    
      //
      // Coordinated state info. PEP proprietary method to return
      // PEP_COORDINATED_STATE_TABLE_PLAT structure.
      //
      // See Pep.h and Pep.c.
      //
      Name (_GCI, Buffer()
      {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
      })
    
      //
      // Device info. PEP proprietary method to return
      // PEP_DEVICE_TABLE_PLAT structure.
      //
      // See Pep.h and Pep.c.
      //
      Name (_GDI, Buffer()
      {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x5F, 0x00, 0x53,
        0x00, 0x42, 0x00, 0x2E, 0x00, 0x49, 0x00, 0x32, 0x00, 0x43, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      })
    }

#if (RPI_MODEL == 4)
    /** @file
     *
     *  Copyright (c) 2019 Linaro, Limited. All rights reserved.
     *  Copyright (c) 2019 Andrei Warkentin <andrey.warkentin@gmail.com>
     *
     *  SPDX-License-Identifier: BSD-2-Clause-Patent
     *
     **/
    
    #include <IndustryStandard/Bcm2711.h>
    
    /*
     * The following can be used to remove parenthesis from
     * defined macros that the compiler complains about.
     */
    #define ISOLATE_ARGS(...)               __VA_ARGS__
    #define REMOVE_PARENTHESES(x)           ISOLATE_ARGS x
    
    #define SANITIZED_PCIE_CPU_MMIO_WINDOW  REMOVE_PARENTHESES(PCIE_CPU_MMIO_WINDOW)
    #define SANITIZED_PCIE_REG_BASE         REMOVE_PARENTHESES(PCIE_REG_BASE)
    
    /*
     * According to UEFI boot log for the VLI device on Pi 4.
     */
    #define XHCI_REG_LENGTH                 0x1000
    
    Device (SCB0) {
        Name (_HID, "ACPI0004")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
    
        Method (_CRS, 0, Serialized) { // _CRS: Current Resource Settings
            /*
             * Container devices with _DMA must have _CRS, meaning SCB0
             * to provide all resources that XHC0 consumes (except
             * interrupts).
             */
            Name (RBUF, ResourceTemplate () {
                QWordMemory (ResourceProducer,
                    ,
                    MinFixed,
                    MaxFixed,
                    NonCacheable,
                    ReadWrite,
                    0x0,
                    SANITIZED_PCIE_CPU_MMIO_WINDOW, // MIN
                    SANITIZED_PCIE_CPU_MMIO_WINDOW, // MAX
                    0x0,
                    0x1,                            // LEN
                    ,
                    ,
                    MMIO
                    )
            })
            CreateQwordField (RBUF, MMIO._MAX, MMBE)
            CreateQwordField (RBUF, MMIO._LEN, MMLE)
            Add (MMBE, XHCI_REG_LENGTH - 1, MMBE)
            Add (MMLE, XHCI_REG_LENGTH - 1, MMLE)
            Return (RBUF)
        }
    
        Name (_DMA, ResourceTemplate() {
            /*
             * XHC0 is limited to DMA to first 3GB. Note this
             * only applies to PCIe, not GENET or other devices
             * next to the A72.
             */
            QWordMemory (ResourceConsumer,
                ,
                MinFixed,
                MaxFixed,
                NonCacheable,
                ReadWrite,
                0x0,
                0x0,        // MIN
                0xbfffffff, // MAX
                0x0,        // TRA
                0xc0000000, // LEN
                ,
                ,
                )
        })
    
        Device (XHC0)
        {
            Name (_HID, "PNP0D10")      // _HID: Hardware ID
            Name (_UID, 0x0)            // _UID: Unique ID
            Name (_CCA, 0x0)            // _CCA: Cache Coherency Attribute
    
            Method (_CRS, 0, Serialized) { // _CRS: Current Resource Settings
                Name (RBUF, ResourceTemplate () {
                    QWordMemory (ResourceConsumer,
                        ,
                        MinFixed,
                        MaxFixed,
                        NonCacheable,
                        ReadWrite,
                        0x0,
                        SANITIZED_PCIE_CPU_MMIO_WINDOW, // MIN
                        SANITIZED_PCIE_CPU_MMIO_WINDOW, // MAX
                        0x0,
                        0x1,                            // LEN
                        ,
                        ,
                        MMIO
                        )
                    Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive, ,, ) {
                        175
                    }
                })
                CreateQwordField (RBUF, MMIO._MAX, MMBE)
                CreateQwordField (RBUF, MMIO._LEN, MMLE)
                Add (MMBE, XHCI_REG_LENGTH - 1, MMBE)
                Add (MMLE, XHCI_REG_LENGTH - 1, MMLE)
                Return (RBUF)
            }
    
            Method (_INI, 0, Serialized) {
                OperationRegion (PCFG, SystemMemory, SANITIZED_PCIE_REG_BASE + PCIE_EXT_CFG_DATA, 0x1000)
                Field (PCFG, AnyAcc, NoLock, Preserve) {
                    VNID, 16, // Vendor ID
                    DVID, 16, // Device ID
                    CMND, 16, // Command register
                    STAT, 16, // Status register
                }
    
                // Set command register to:
                // 1) decode MMIO (set bit 1)
                // 2) enable DMA (set bit 2)
                // 3) enable interrupts (clear bit 10)
                Debug = "xHCI enable"
                Store (0x6, CMND)
            }
        }
    }

#endif

    Device (CPU0)
    {
      Name (_HID, "ACPI0007")
      Name (_UID, 0x0)
      Method (_STA)
      {
        Return (0xf)
      }
    }

    Device (CPU1)
    {
      Name (_HID, "ACPI0007")
      Name (_UID, 0x1)
      Method (_STA)
      {
        Return (0xf)
      }
    }

    Device (CPU2)
    {
      Name (_HID, "ACPI0007")
      Name (_UID, 0x2)
      Method (_STA)
      {
        Return (0xf)
      }
    }

    Device (CPU3)
    {
      Name (_HID, "ACPI0007")
      Name (_UID, 0x3)
      Method (_STA)
      {
        Return (0xf)
      }
    }

    //
    // GPU device container describes the DMA translation required
    // when a device behind the GPU wants to access Arm memory.
    // Only the first GB can be addressed.
    //
    Device (GDV0)
    {
      Name (_HID, "ACPI0004")
      Name (_UID, 0x1)
      Name (_CCA, 0x0)

      Method (_CRS, 0, Serialized) {
        //
        // Container devices with _DMA must have _CRS, meaning GDV0
        // to provide all resources that GpuDevs.asl consume (except
        // interrupts).
        //
        Name (RBUF, ResourceTemplate () {
          QWORDMEMORYBUF(01)
          QWORDMEMORYBUF(02)
          QWORDMEMORYBUF(03)
          // QWORDMEMORYBUF(04)
          // QWORDMEMORYBUF(05)
          QWORDMEMORYBUF(06)
          QWORDMEMORYBUF(07)
          QWORDMEMORYBUF(08)
          QWORDMEMORYBUF(09)
          QWORDMEMORYBUF(10)
          QWORDMEMORYBUF(11)
          QWORDMEMORYBUF(12)
          QWORDMEMORYBUF(13)
          QWORDMEMORYBUF(14)
          QWORDMEMORYBUF(15)
          // QWORDMEMORYBUF(16)
          QWORDMEMORYBUF(17)
          QWORDMEMORYBUF(18)
          QWORDMEMORYBUF(19)
          QWORDMEMORYBUF(20)
          QWORDMEMORYBUF(21)
          QWORDMEMORYBUF(22)
          QWORDMEMORYBUF(23)
          QWORDMEMORYBUF(24)
          QWORDMEMORYBUF(25)
        })

        // USB
        QWORDMEMORYSET(01, BCM2836_USB_OFFSET, BCM2836_USB_LENGTH)

        // GPU
        QWORDMEMORYSET(02, BCM2836_V3D_BUS_OFFSET, BCM2836_V3D_BUS_LENGTH)
        QWORDMEMORYSET(03, BCM2836_HVS_OFFSET, BCM2836_HVS_LENGTH)
        // QWORDMEMORYSET(04, BCM2836_PV0_OFFSET, BCM2836_PV0_LENGTH)
        // QWORDMEMORYSET(05, BCM2836_PV1_OFFSET, BCM2836_PV1_LENGTH)
        QWORDMEMORYSET(06, BCM2836_PV2_OFFSET, BCM2836_PV2_LENGTH)
        QWORDMEMORYSET(07, BCM2836_HDMI0_OFFSET, BCM2836_HDMI0_LENGTH)
        QWORDMEMORYSET(08, BCM2836_HDMI1_OFFSET, BCM2836_HDMI1_LENGTH)

        // Mailbox
        QWORDMEMORYSET(09, BCM2836_MBOX_OFFSET, BCM2836_MBOX_LENGTH)

        // VCHIQ
        QWORDMEMORYSET(10, BCM2836_VCHIQ_OFFSET, BCM2836_VCHIQ_LENGTH)

        // GPIO
        QWORDMEMORYSET(11, GPIO_OFFSET, GPIO_LENGTH)

        // I2C
        QWORDMEMORYSET(12, BCM2836_I2C1_OFFSET, BCM2836_I2C1_LENGTH)
        QWORDMEMORYSET(13, BCM2836_I2C2_OFFSET, BCM2836_I2C2_LENGTH)

        // SPI
        QWORDMEMORYSET(14, BCM2836_SPI0_OFFSET, BCM2836_SPI0_LENGTH)
        QWORDMEMORYSET(15, BCM2836_SPI1_OFFSET, BCM2836_SPI1_LENGTH)
        // QWORDMEMORYSET(16, BCM2836_SPI2_OFFSET, BCM2836_SPI2_LENGTH)

        // PWM
        QWORDMEMORYSET(17, BCM2836_PWM_DMA_OFFSET, BCM2836_PWM_DMA_LENGTH)
        QWORDMEMORYSET(18, BCM2836_PWM_CTRL_OFFSET, BCM2836_PWM_CTRL_LENGTH)
        QWORDBUSMEMORYSET(19, BCM2836_PWM_BUS_BASE_ADDRESS, BCM2836_PWM_BUS_LENGTH)
        QWORDBUSMEMORYSET(20, BCM2836_PWM_CTRL_UNCACHED_BASE_ADDRESS, BCM2836_PWM_CTRL_UNCACHED_LENGTH)
        QWORDMEMORYSET(21, BCM2836_PWM_CLK_OFFSET, BCM2836_PWM_CLK_LENGTH)

        // UART
        QWORDMEMORYSET(22, BCM2836_PL011_UART_OFFSET, BCM2836_PL011_UART_LENGTH)
        QWORDMEMORYSET(23, BCM2836_MINI_UART_OFFSET, BCM2836_MINI_UART_LENGTH)

        // SDC
        QWORDMEMORYSET(24, MMCHS1_OFFSET, MMCHS1_LENGTH)
        QWORDMEMORYSET(25, SDHOST_OFFSET, SDHOST_LENGTH)

        Return (RBUF)
      }

      Name (_DMA, ResourceTemplate() {
        //
        // Only the first GB is available.
        // Bus 0xC0000000 -> CPU 0x00000000.
        //
        QWordMemory (ResourceConsumer,
          ,
          MinFixed,
          MaxFixed,
          NonCacheable,
          ReadWrite,
          0x0,
          0x00000000C0000000, // MIN
          0x00000000FFFFFFFF, // MAX
          0xFFFFFFFF40000000, // TRA
          0x0000000040000000, // LEN
          ,
          ,
          )
      })
      /** @file
       *
       *  [DSDT] Devices behind the GPU.
       *
       *  Copyright (c) 2018-2020, Andrey Warkentin <andrey.warkentin@gmail.com>
       *  Copyright (c) Microsoft Corporation. All rights reserved.
       *
       *  SPDX-License-Identifier: BSD-2-Clause-Patent
       *
       **/
      
      // DWC OTG Controller
      Device (USB0)
      {
        Name (_HID, "BCM2848")
        Name (_CID, Package() { "DWC_OTG", "DWC2_OTG" })
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_USB_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_USB_INTERRUPT }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_USB_OFFSET)
          Return (^RBUF)
        }
      }
      
      // Video Core 4 GPU
      Device (GPU0)
      {
        Name (_HID, "BCM2850")
        Name (_CID, "VC4")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          // Memory and interrupt for the GPU
          MEMORY32FIXED (ReadWrite, 0, BCM2836_V3D_BUS_LENGTH, RM01)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_V3D_BUS_INTERRUPT }
      
          // HVS - Hardware Video Scalar
          MEMORY32FIXED (ReadWrite, 0, BCM2836_HVS_LENGTH, RM02)
          // The HVS interrupt is reserved by the VPU
          // Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_HVS_INTERRUPT }
      
          // PixelValve0 - DSI0 or DPI
          // MEMORY32FIXED (ReadWrite, BCM2836_PV0_BASE_ADDRESS, BCM2836_PV0_LENGTH, RM03)
          // Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_PV0_INTERRUPT }
      
          // PixelValve1 - DS1 or SMI
          // MEMORY32FIXED (ReadWrite, BCM2836_PV1_BASE_ADDRESS, BCM2836_PV1_LENGTH, RM04)
          // Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_PV1_INTERRUPT }
      
          // PixelValve2 - HDMI output - connected to HVS display FIFO 1
          MEMORY32FIXED (ReadWrite, 0, BCM2836_PV2_LENGTH, RM05)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_PV2_INTERRUPT }
      
          // HDMI registers
          MEMORY32FIXED (ReadWrite, 0, BCM2836_HDMI0_LENGTH, RM06)
          MEMORY32FIXED (ReadWrite, 0, BCM2836_HDMI1_LENGTH, RM07)
          // hdmi_int[0]
          // Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_HDMI0_INTERRUPT }
          // hdmi_int[1]
          // Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_HDMI1_INTERRUPT }
      
          // HDMI DDC connection
          I2CSerialBus (0x50,, 100000,, "\\_SB.GDV0.I2C2",,,,)  // EDID
          I2CSerialBus (0x30,, 100000,, "\\_SB.GDV0.I2C2",,,,)  // E-DDC Segment Pointer
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RM01, RB01, BCM2836_V3D_BUS_OFFSET)
          MEMORY32SETBASE (RBUF, RM02, RB02, BCM2836_HVS_OFFSET)
          MEMORY32SETBASE (RBUF, RM05, RB05, BCM2836_PV2_OFFSET)
          MEMORY32SETBASE (RBUF, RM06, RB06, BCM2836_HDMI0_OFFSET)
          MEMORY32SETBASE (RBUF, RM07, RB07, BCM2836_HDMI1_OFFSET)
          Return (^RBUF)
        }
      
        // GPU Power Management Component Data
        // Reference : https://github.com/Microsoft/graphics-driver-samples/wiki/Install-Driver-in-a-Windows-VM
        Method (PMCD, 0, Serialized)
        {
          Name (RBUF, Package ()
          {
            1,                  // Version
            1,                  // Number of graphics power components
            Package ()          // Power components package
            {
              Package ()        // GPU component package
              {
                0,              // Component Index
                0,              // DXGK_POWER_COMPONENT_MAPPING.ComponentType (0 = DXGK_POWER_COMPONENT_ENGINE)
                0,              // DXGK_POWER_COMPONENT_MAPPING.NodeIndex
      
                Buffer ()       // DXGK_POWER_RUNTIME_COMPONENT.ComponentGuid
                {               // 9B2D1E26-1575-4747-8FC0-B9EB4BAA2D2B
                  0x26, 0x1E, 0x2D, 0x9B, 0x75, 0x15, 0x47, 0x47,
                  0x8f, 0xc0, 0xb9, 0xeb, 0x4b, 0xaa, 0x2d, 0x2b
                },
      
                "VC4_Engine_00",// DXGK_POWER_RUNTIME_COMPONENT.ComponentName
                2,              // DXGK_POWER_RUNTIME_COMPONENT.StateCount
      
                Package ()      // DXGK_POWER_RUNTIME_COMPONENT.States[] package
                {
                  Package ()   // F0
                  {
                    0,         // DXGK_POWER_RUNTIME_STATE.TransitionLatency
                    0,         // DXGK_POWER_RUNTIME_STATE.ResidencyRequirement
                    1210000,   // DXGK_POWER_RUNTIME_STATE.NominalPower (microwatt)
                  },
      
                  Package ()   // F1 - Placeholder
                  {
                    10000,     // DXGK_POWER_RUNTIME_STATE.TransitionLatency
                    10000,     // DXGK_POWER_RUNTIME_STATE.ResidencyRequirement
                    4,         // DXGK_POWER_RUNTIME_STATE.NominalPower
                  },
                }
              }
            }
          })
          Return (RBUF)
        }
      }
      
      // PiQ Mailbox Driver
      Device (RPIQ)
      {
        Name (_HID, "BCM2849")
        Name (_CID, "RPIQ")
        Name (_UID, 0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_MBOX_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_MBOX_INTERRUPT }
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_MBOX_OFFSET)
          Return (^RBUF)
        }
      }
      
      // VCHIQ Driver
      Device (VCIQ)
      {
        Name (_HID, "BCM2835")
        Name (_CID, "VCIQ")
        Name (_UID, 0)
        Name (_CCA, 0x0)
        Name (_DEP, Package() { \_SB.GDV0.RPIQ })
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_VCHIQ_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_VCHIQ_INTERRUPT }
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_VCHIQ_OFFSET)
          Return (^RBUF)
        }
      }
      
      // VC Shared Memory Driver
      Device (VCSM)
      {
        Name (_HID, "BCM2856")
        Name (_CID, "VCSM")
        Name (_UID, 0)
        Name (_CCA, 0x0)
        Name (_DEP, Package() { \_SB.GDV0.VCIQ })
        Method (_STA)
        {
          Return (0xf)
        }
      }
      
      // Description: GPIO
      Device (GPI0)
      {
        Name (_HID, "BCM2845")
        Name (_CID, "BCMGPIO")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return(0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, GPIO_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared)
          {
            BCM2386_GPIO_INTERRUPT0, BCM2386_GPIO_INTERRUPT1,
            BCM2386_GPIO_INTERRUPT2, BCM2386_GPIO_INTERRUPT3
          }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, GPIO_OFFSET)
          Return (^RBUF)
        }
      }
      
      // Description: I2C
      Device (I2C1)
      {
        Name (_HID, "BCM2841")
        Name (_CID, "BCMI2C")
        Name (_UID, 0x1)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return(0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_I2C1_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { BCM2836_I2C1_INTERRUPT }
          PinFunction (Exclusive, PullUp, BCM_ALT0, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 2, 3 }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_I2C1_OFFSET)
          Return (^RBUF)
        }
      }
      
      // I2C2 is the HDMI DDC connection
      Device (I2C2)
      {
        Name (_HID, "BCM2841")
        Name (_CID, "BCMI2C")
        Name (_UID, 0x2)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_I2C2_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { BCM2836_I2C2_INTERRUPT }
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_I2C2_OFFSET)
          Return (^RBUF)
        }
      }
      
      // SPI
      Device (SPI0)
      {
        Name (_HID, "BCM2838")
        Name (_CID, "BCMSPI0")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_SPI0_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { BCM2836_SPI0_INTERRUPT }
          PinFunction (Exclusive, PullDown, BCM_ALT0, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 9, 10, 11 } // MISO, MOSI, SCLK
          PinFunction (Exclusive, PullUp, BCM_ALT0, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 8 } // CE0
          PinFunction (Exclusive, PullUp, BCM_ALT0, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 7 } // CE1
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_SPI0_OFFSET)
          Return (^RBUF)
        }
      }
      
      Device (SPI1)
      {
        Name (_HID, "BCM2839")
        Name (_CID, "BCMAUXSPI")
        Name (_UID, 0x1)
        Name (_CCA, 0x0)
        Name (_DEP, Package() { \_SB.GDV0.RPIQ })
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_SPI1_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared,) { BCM2836_SPI1_INTERRUPT }
          PinFunction (Exclusive, PullDown, BCM_ALT4, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 19, 20, 21 } // MISO, MOSI, SCLK
          PinFunction (Exclusive, PullDown, BCM_ALT4, "\\_SB.GDV0.GPI0", 0, ResourceConsumer, , ) { 16 } // CE2
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_SPI1_OFFSET)
          Return (^RBUF)
        }
      }
      
      // SPI2 has no pins on GPIO header
      // Device (SPI2)
      // {
      //   Name (_HID, "BCM2839")
      //   Name (_CID, "BCMAUXSPI")
      //   Name (_UID, 0x2)
      //   Name (_CCA, 0x0)
      //   Name (_DEP, Package() { \_SB.GDV0.RPIQ })
      //   Method (_STA)
      //   {
      //     Return (0xf)     // Disabled
      //   }
      //   Method (_CRS, 0x0, Serialized)
      //   {
      //     Name (RBUF, ResourceTemplate ()
      //     {
      //       MEMORY32FIXED (ReadWrite, BCM2836_SPI2_BASE_ADDRESS, BCM2836_SPI2_LENGTH, RMEM)
      //       Interrupt (ResourceConsumer, Level, ActiveHigh, Shared,) { BCM2836_SPI2_INTERRUPT }
      //     })
      //     Return (RBUF)
      //   }
      // }
      
      // PWM Driver
      Device (PWM0)
      {
        Name (_HID, "BCM2844")
        Name (_CID, "BCM2844")
        Name (_UID, 0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          // DMA channel 11 control
          MEMORY32FIXED (ReadWrite, 0, BCM2836_PWM_DMA_LENGTH, RM01)
          // PWM control
          MEMORY32FIXED (ReadWrite, 0, BCM2836_PWM_CTRL_LENGTH, RM02)
          // PWM control bus
          MEMORY32FIXED (ReadWrite, BCM2836_PWM_BUS_BASE_ADDRESS, BCM2836_PWM_BUS_LENGTH, )
          // PWM control uncached
          MEMORY32FIXED (ReadWrite, BCM2836_PWM_CTRL_UNCACHED_BASE_ADDRESS, BCM2836_PWM_CTRL_UNCACHED_LENGTH, )
          // PWM clock control
          MEMORY32FIXED (ReadWrite, 0, BCM2836_PWM_CLK_LENGTH, RM03)
          // Interrupt DMA channel 11
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_DMA_INTERRUPT }
          // DMA channel 11, DREQ 5 for PWM
          FixedDMA (5, 11, Width32Bit, )
        })
      
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RM01, RB01, BCM2836_PWM_DMA_OFFSET)
          MEMORY32SETBASE (RBUF, RM02, RB02, BCM2836_PWM_CTRL_OFFSET)
          MEMORY32SETBASE (RBUF, RM03, RB03, BCM2836_PWM_CLK_OFFSET)
          Return (^RBUF)
        }
      }
      
      /** @file
       *
       *  [DSDT] Serial devices (UART).
       *
       *  Copyright (c) 2020, Pete Batard <pete@akeo.ie>
       *  Copyright (c) 2018, Andrey Warkentin <andrey.warkentin@gmail.com>
       *  Copyright (c) Microsoft Corporation. All rights reserved.
       *
       *  SPDX-License-Identifier: BSD-2-Clause-Patent
       *
       **/
      
      #include <IndustryStandard/Bcm2836.h>
      
      #include "AcpiTables.h"
      
      // PL011 based UART.
      Device (URT0)
      {
        Name (_HID, "BCM2837")
        Name (_CID, "ARMH0011")
        Name (_UID, 0x4)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_PL011_UART_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_PL011_UART_INTERRUPT }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_PL011_UART_OFFSET)
          Return (^RBUF)
        }
      
        Name (CLCK, 48000000)
      
        Name (_DSD, Package ()
        {
          ToUUID ("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), Package ()
          {
            Package (2) { "clock-frequency", CLCK },
          }
        })
      }
      
      //
      // UART Mini.
      //
      // This device is referenced in the DBG2 table, which will cause the system to
      // not start the driver when the debugger is enabled and to mark the device
      // with problem code 53 (CM_PROB_USED_BY_DEBUGGER).
      //
      
      Device (URTM)
      {
        Name (_HID, "BCM2836")
        Name (_CID, "MINIUART")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, BCM2836_MINI_UART_LENGTH, RMEM)
          Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) { BCM2836_MINI_UART_INTERRUPT }
      
          // NTRAID#MSFT-7141401-2016/04/7-jordanrh - disable UART muxing
          // until a proper solution can be created for the dmap conflict.
          // When muxing is enabled, must consider DBG2 table conflict.
          // The alternate function resource needs to be reserved when
          // the kernel debugger is enabled to prevent another client
          // from muxing the pins away.
      
          // PinFunction (Exclusive, PullDown, BCM_ALT5, "\\_SB.GPI0", 0, ResourceConsumer, , ) { 14, 15 }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, BCM2836_MINI_UART_OFFSET)
          Return (^RBUF)
        }
      }
      
      //
      // Multifunction serial bus device to support Bluetooth function.
      //
      Device(BTH0)
      {
        Name (_HID, "BCM2EA6")
        Name (_CID, "BCM2EA6")
        Method (_STA)
        {
          Return (0xf)
        }
        Method (_CRS, 0x0, Serialized)
        {
          Name (RBUF, ResourceTemplate ()
          {
            // BT UART: URT0 (PL011) or URTM (miniUART)
            UARTSerialBus(
              115200,        // InitialBaudRate: in BPS
              ,              // BitsPerByte: default to 8 bits
              ,              // StopBits: Defaults to one bit
              0x00,          // LinesInUse: 8 1-bit flags to
                             //   declare enabled control lines.
                             //   Raspberry Pi does not exposed
                             //   HW control signals -> not supported.
                             //   Optional bits:
                             //   - Bit 7 (0x80) Request To Send (RTS)
                             //   - Bit 6 (0x40) Clear To Send (CTS)
                             //   - Bit 5 (0x20) Data Terminal Ready (DTR)
                             //   - Bit 4 (0x10) Data Set Ready (DSR)
                             //   - Bit 3 (0x08) Ring Indicator (RI)
                             //   - Bit 2 (0x04) Data Carrier Detect (DTD)
                             //   - Bit 1 (0x02) Reserved. Must be 0.
                             //   - Bit 0 (0x01) Reserved. Must be 0.
              ,              // IsBigEndian:
                             //   default to LittleEndian.
              ,              // Parity: Defaults to no parity
              ,              // FlowControl: Defaults to
                             //   no flow control.
              16,            // ReceiveBufferSize
              16,            // TransmitBufferSize
      #if (RPI_MODEL == 4)
              "\\_SB.GDV0.URTM",  // ResourceSource:
      #else
              "\\_SB.GDV0.URT0",  // ResourceSource:
      #endif
                             //   UART bus controller name
              ,              // ResourceSourceIndex: assumed to be 0
              ,              // ResourceUsage: assumed to be
                             //   ResourceConsumer
              UAR0,          // DescriptorName: creates name
                             //   for offset of resource descriptor
            )                // Vendor data
      
            //
            // RPIQ connection for BT_ON/OFF
            //
            GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.RPIQ", 0, ResourceConsumer, , ) { 128 }
          })
          Return (RBUF)
        }
      }

      /** @file
       *
       *  [DSDT] RHProxy device to enable WinRT API (RHPX)
       *
       *  Copyright (c) 2018, Andrey Warkentin <andrey.warkentin@gmail.com>
       *  Copyright (c) Microsoft Corporation. All rights reserved.
       *
       *  SPDX-License-Identifier: BSD-2-Clause-Patent
       *
       **/
      
      Device (RHPX)
      {
        Name (_HID, "MSFT8000")
        Name (_CID, "MSFT8000")
        Name (_UID, 1)
      
        Name(_CRS, ResourceTemplate ()
        {
          // Index 0
          SPISerialBus (           // SCKL - GPIO 11 - Pin 23
                                   // MOSI - GPIO 10 - Pin 19
                                   // MISO - GPIO 9  - Pin 21
                                   // CE0  - GPIO 8  - Pin 24
            0,                     // Device selection (CE0)
            PolarityLow,           // Device selection polarity
            FourWireMode,          // WireMode
            8,                     // DataBit len
            ControllerInitiated,   // Slave mode
            4000000,               // Connection speed
            ClockPolarityLow,      // Clock polarity
            ClockPhaseFirst,       // Clock phase
            "\\_SB.GDV0.SPI0",     // ResourceSource: SPI bus controller name
            0,                     // ResourceSourceIndex
                                   // Resource usage
                                   // DescriptorName: creates name for offset of resource descriptor
          )                        // Vendor Data
      
          // Index 1
          SPISerialBus (           // SCKL - GPIO 11 - Pin 23
                                   // MOSI - GPIO 10 - Pin 19
                                   // MISO - GPIO 9  - Pin 21
                                   // CE1  - GPIO 7  - Pin 26
            1,                     // Device selection (CE1)
            PolarityLow,           // Device selection polarity
            FourWireMode,          // WireMode
            8,                     // DataBit len
            ControllerInitiated,   // Slave mode
            4000000,               // Connection speed
            ClockPolarityLow,      // Clock polarity
            ClockPhaseFirst,       // Clock phase
            "\\_SB.GDV0.SPI0",     // ResourceSource: SPI bus controller name
            0,                     // ResourceSourceIndex
                                   // Resource usage
                                   // DescriptorName: creates name for offset of resource descriptor
          )                        // Vendor Data
      
          // Index 2
          I2CSerialBus (           // Pin 3 (GPIO2, SDA1), 5 (GPIO3, SCL1)
            0xFFFF,                // SlaveAddress: placeholder
            ,                      // SlaveMode: default to ControllerInitiated
            0,                     // ConnectionSpeed: placeholder
            ,                      // Addressing Mode: default to 7 bit
            "\\_SB.GDV0.I2C1",     // ResourceSource: I2C bus controller name
            ,
            ,
            ,                      // Descriptor Name: creates name for offset of resource descriptor
          )                        // Vendor Data
      
          // Index 3
          SPISerialBus (           // SPI1_SCLK - GPIO21
                                   // SPI1_MOSI - GPIO20
                                   // SPI1_MISO - GPIO19
                                   // SPI1_CE2_N - GPIO16
            2,                     // Device selection (CE2)
            PolarityLow,           // Device selection polarity
            FourWireMode,          // WireMode
            8,                     // DataBit len
            ControllerInitiated,   // Slave mode
            4000000,               // Connection speed
            ClockPolarityLow,      // Clock polarity
            ClockPhaseFirst,       // Clock phase
            "\\_SB.GDV0.SPI1",          // ResourceSource: SPI bus controller name
            0,                     // ResourceSourceIndex
                                   // Resource usage
                                   // DescriptorName: creates name for offset of resource descriptor
          )                        // Vendor Data
      
          // GPIO 2
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 2 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 2 }
          // GPIO 3
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 3 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 3 }
          // GPIO 4
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 4 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 4 }
          // GPIO 5
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 5 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 5 }
          // GPIO 6
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 6 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 6 }
          // GPIO 7
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 7 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 7 }
          // GPIO 8
          GpioIO (Shared, PullUp, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 8 }
          GpioInt (Edge, ActiveBoth, Shared, PullUp, 0, "\\_SB.GDV0.GPI0",)                          { 8 }
          // GPIO 9
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 9 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 9 }
          // GPIO 10
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 10 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 10 }
          // GPIO 11
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 11 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 11 }
          // GPIO 12
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 12 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 12 }
          // GPIO 13
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 13 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 13 }
          // NTRAID#MSFT-7141401-2016/04/7-jordanrh - disable UART muxing
          // until a proper solution can be created for the dmap conflict
          // GPIO 14 - UART TX
          // GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 14 }
          // GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 14 }
          // GPIO 15 - UART RX
          // GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 15 }
          // GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 15 }
          // GPIO 16
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 16 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 16 }
          // GPIO 17
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 17 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 17 }
          // GPIO 18
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 18 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 18 }
          // GPIO 19
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 19 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 19 }
          // GPIO 20
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 20 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 20 }
          // GPIO 21
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 21 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 21 }
          // GPIO 22
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 22 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 22 }
          // GPIO 23
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 23 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 23 }
          // GPIO 24
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 24 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 24 }
          // GPIO 25
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 25 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 25 }
          // GPIO 26
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 26 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 26 }
          // GPIO 27
          GpioIO (Shared, PullDown, 0, 0, IoRestrictionNone, "\\_SB.GDV0.GPI0", 0, ResourceConsumer,,) { 27 }
          GpioInt (Edge, ActiveBoth, Shared, PullDown, 0, "\\_SB.GDV0.GPI0",)                          { 27 }
        })
      
        Name (_DSD, Package()
        {
          ToUUID ("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package ()
          {
            // Reference http://www.raspberrypi.org/documentation/hardware/raspberrypi/spi/README.md
            // SPI 0
            Package (2) { "bus-SPI-SPI0", Package() { 0, 1 } },                   // Index 0 & 1
            Package (2) { "SPI0-MinClockInHz", 7629 },                            // 7629 Hz
            Package (2) { "SPI0-MaxClockInHz", 125000000 },                       // 125 MHz
            Package (2) { "SPI0-SupportedDataBitLengths", Package() { 8 } },      // Data Bit Length
            // I2C1
            Package (2) { "bus-I2C-I2C1", Package() { 2 } },
            // GPIO Pin Count and supported drive modes
            Package (2) { "GPIO-PinCount", 54 },
            Package (2) { "GPIO-UseDescriptorPinNumbers", 1 },
            Package (2) { "GPIO-SupportedDriveModes", 0xf },                      // InputHighImpedance, InputPullUp, InputPullDown, OutputCmos
            // SPI 1
            Package (2) { "bus-SPI-SPI1", Package() { 3 }},                       // Index 3
            Package (2) { "SPI1-MinClockInHz", 30511 },                           // 30.5 kHz
            Package (2) { "SPI1-MaxClockInHz", 20000000 },                        // 20 MHz
            Package (2) { "SPI1-SupportedDataBitLengths", Package() { 8 } },      // Data Bit Length
          }
        })
      }

      /** @file
       *
       *  [DSDT] SD controller/card definition (SDHC)
       *
       *  Copyright (c) 2020, Pete Batard <pete@akeo.ie>
       *  Copyright (c) 2018, Andrey Warkentin <andrey.warkentin@gmail.com>
       *  Copyright (c) Microsoft Corporation. All rights reserved.
       *
       *  SPDX-License-Identifier: BSD-2-Clause-Patent
       *
       **/
      
      #include <IndustryStandard/Bcm2836SdHost.h>
      #include <IndustryStandard/Bcm2836Sdio.h>
      
      #include "AcpiTables.h"
      
      //
      // Note: UEFI can use either SDHost or Arasan. We expose both to the OS.
      //
      
      // ArasanSD 3.0 SD Host Controller. (brcm,bcm2835-sdhci)
      Device (SDC1)
      {
        Name (_HID, "BCM2847")
        Name (_CID, "ARASAN")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Name (_S1D, 0x1)
        Name (_S2D, 0x1)
        Name (_S3D, 0x1)
        Name (_S4D, 0x1)
        Method (_STA)
        {
          Return(0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, MMCHS1_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Shared) { BCM2836_MMCHS1_INTERRUPT }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, MMCHS1_OFFSET)
          Return (^RBUF)
        }
      
        // The standard CAPs registers on this controller
        // appear to be 0, lets set some minimal defaults
        // Since this cap doesn't indicate DMA capability
        // we don't need a _DMA()
        Name (_DSD, Package () {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package () { "sdhci-caps", 0x0100fa81 },
          }
        })
      
        //
        // A child device that represents the
        // sd card, which is marked as non-removable.
        //
        Device (SDMM)
        {
          Method (_ADR)
          {
            Return (0)
          }
          Method (_RMV) // Is removable
          {
            Return (0) // 0 - fixed
          }
        }
      }
      
      #if (RPI_MODEL < 4)
      // Broadcom SDHost 2.0 SD Host Controller
      Device (SDC2)
      {
        Name (_HID, "BCM2855")
        Name (_CID, "SDHST")
        Name (_UID, 0x0)
        Name (_CCA, 0x0)
        Name (_S1D, 0x1)
        Name (_S2D, 0x1)
        Name (_S3D, 0x1)
        Name (_S4D, 0x1)
        Method (_STA)
        {
          Return (0xf)
        }
        Name (RBUF, ResourceTemplate ()
        {
          MEMORY32FIXED (ReadWrite, 0, SDHOST_LENGTH, RMEM)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { BCM2836_SDHOST_INTERRUPT }
        })
        Method (_CRS, 0x0, Serialized)
        {
          MEMORY32SETBASE (RBUF, RMEM, RBAS, SDHOST_OFFSET)
          Return (^RBUF)
        }
      
        //
        // A child device that represents the
        // sd card, which is marked as non-removable.
        //
        Device (SDMM)
        {
          Method (_ADR)
          {
            Return (0)
          }
          Method (_RMV) // Is removable
          {
            Return (0) // 0 - fixed
          }
        }
      }
      #endif // !RPI4


    }

#if (RPI_MODEL == 4)
    Device (ETH0)
    {
      Name (_HID, "BCM6E4E")
      Name (_CID, "BCM6E4E")
      Name (_UID, 0x0)
      Name (_CCA, 0x0)
      Method (_STA)
      {
        Return (0xf)
      }
      Method (_CRS, 0x0, Serialized)
      {
        Name (RBUF, ResourceTemplate ()
        {
          // No need for MEMORY32SETBASE on Genet as we have a straight base address constant
          MEMORY32FIXED (ReadWrite, GENET_BASE_ADDRESS, GENET_LENGTH, )
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { GENET_INTERRUPT0, GENET_INTERRUPT1 }
        })
        Return (RBUF)
      }
      Name (_DSD, Package () {
        ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
        Package () {
          Package () { "brcm,max-dma-burst-size", 0x08 },
          Package () { "phy-mode", "rgmii-rxid" },
        }
      })
    }

    // Define a simple thermal zone. The idea here is we compute the SOC temp
    // via a register we can read, and give it to the OS. This enables basic
    // reports from the "sensors" utility, and the OS can then poll and take
    // actions if that temp exceeds any of the given thresholds.
    Device (EC00)
    {
      Name (_HID, EISAID ("PNP0C06"))
      Name (_CCA, 0x0)

      // all temps in are tenths of K (aka 2732 is the min temps in Linux (aka 0C))
      ThermalZone (TZ00) {
        Method (_TMP, 0, Serialized) {
          OperationRegion (TEMS, SystemMemory, THERM_SENSOR, 0x8)
          Field (TEMS, DWordAcc, NoLock, Preserve) {
            TMPS, 32
          }
          return (((410040 - ((TMPS & 0x3ff) * 487)) / 100) + 2732);
        }
        Method (_SCP, 3) { }               // receive cooling policy from OS

        Method (_CRT) { Return (3632) }    // (90C) Critical temp point (immediate power-off)
        Method (_HOT) { Return (3582) }    // (85C) HOT state where OS should hibernate
        Method (_PSV) { Return (3532) }    // (80C) Passive cooling (CPU throttling) trip point

        // SSDT inserts _AC0/_AL0 @60C here, if a FAN is configured

        Name (_TZP, 10)                   //The OSPM must poll this device every 1 seconds
        Name (_PSL, Package () { \_SB_.CPU0, \_SB_.CPU1, \_SB_.CPU2, \_SB_.CPU3 })
      }
    }
#endif

  }
}
